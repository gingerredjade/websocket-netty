# 参考网站
https://blog.csdn.net/SpringCloudTest/article/details/107770752
https://mp.weixin.qq.com/s/0mjJei_Y4w-ctbLIRF49dg
https://mp.weixin.qq.com/s/YZDuSixZVIpsgjYSd1_aaw
https://blog.csdn.net/qq_41755287/article/details/99948022

# Netty入门之WebSocket初体验

1、 Netty：高性能、事件驱动、异步非阻塞的IO Java开源框架，由JBoss提供，用于建立TCP等底层的链接。基于Netty可以建立高性能的HTTP服务器，快速开发高性能高可靠性的网络服务器和客户端程序。

它支持HTTP WebSocket protobuf tcp udp。

2、 Netty是基于NIO的服务端、客户端编程框架。使用Netty可以确保快速、简单地开发出一个网络应用。

3、提供了稳定性和良好的伸缩性。

4、使用场景：

	- 高性能领域，如游戏、分布式计算等领域。
 - 多线程并发领域。Netty的多线程采用rector模型，主要有多路复用器、事件分发器、事件处理器组成。可以分为三种：
   	- 单线程模型，所有的IO都由一个线程完成。
   	- 多线程模型。
   	- 主从多线程模型。
	- 异步通信领域。



# 一、IO通信

## 1.BIO

- 一个线程负责连接；
- 一请求一应答；
- 缺乏弹性伸缩能力。当线程数膨胀之后，系统的性能急剧下降，随着并发访问量的急剧增大，系统将会发生线程堆栈溢出，创建新线程失败等问题，最终导致进程宕机或者僵死不能对外提供服务。

采用BIO通信模型的服务端，由一个独立的accepter线程负责监听客户端的连接，它接收到客户端的连接请求之后，为每个客户端创建一个新的线程进行链路处理。处理完成之后，通过输出流返回应答给客户端。此时线程销毁。

## 2.伪异步IO通信

- 线程池负责连接
- M请求N应答
- 线程池阻塞

当有新的客户端接入的时候，将客户端的socket封装成一个task投递到后端的线程池中进行处理。

JDK的线程池维护一个消息队列和N个活跃的线程对消息队列中的任务进行相应的处理，也就是说，当有M个客户端接入的时候，服务端将会创建一个具有N个线程的线程池，来对客户端的请求进行处理。

由于线程池可以设置消息队列的大小和最大线程数，因此它的资源是可控的，无论多少个客户端并发访问都不会导致资源的耗尽和宕机，但是它也有不足的地方，当有大量的客户端接入的时候，随着并发访问量的不断增加，伪异步IO通信可能会造成线程池阻塞。

## 3.NIO

- 缓冲区Buffer：是一个对象，包含一些要写入或者要读出的数据，在NIO类库中加入Buffer对象，体现了新库与原IO的重要区别：在面向流的IO中，可以将数据直接写入或者将数据直接读到stream对象中。在NIO库中，所有数据都是用缓冲区处理的，在读取数据的时候，是直接读的缓冲区中，在写入数据的时候，是写入到缓冲区中，任何时候访问NIO中的数据都是通过缓冲区进行操作。
- 通道Channel。网络数据通过Channel读取和写入，通道是双向的，流是在一个方向上移动。一个流必须是InputStream或者OutputStream的子类，而通道可以用读写或者二者同时进行。
- 多路复用器Selector。JavaNIO编程的基础，提供了选择已经就绪任务的能力，Selector会不断地轮训注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮训出来，然后通过Selection Key可以获取就绪Channel的集合，进行后续的IO操作。由于JDK使用了Eppo代替传统的Select实现，所以它并没有最大连接数的限制，可以接入成千上万的客户端，这在IO通信领域是一个非常大的进步。



## 4.AIO

- 连接注册读写事件和回调函数。
- 读写方法异步。
- 主动通知程序。

高效内存数据模型

计算存储一体



借助云原生的能力即资源池化、资源解耦，来提供更好的、更低的成本，更方便的使用方式，来提供高效的内存的预存储能力，并且希望实现计存一体（将计算和内存数据的访问一体化）。

提供两种方式获取操作结果：

- java.util.concurrent.Future来表示异步操作的结果。
- 在执行异步操作的时候传入java.nio.channels.completionHandler接口的实现类作为操作完成回调。

AIO的异步套接字通道是真正的异步非阻塞IO，对应于Unix网络编程中的事件驱动IO，它不需要通过多路复用器对注册的通道进行轮训操作即可实现异步读写，从而简化了NIO的编程模型。

## 5.对比

- 客户端个数
  - BIO： 客户端个数和IP线程数呈1：1关系。
  - 伪异步IO： 客户端个数和IP线程数呈M:N关系。
  - NIO： 客户端个数和IP线程数呈M:1关系。
  - AIO： 客户端个数和IP线程数呈M：0关系。不需要启动额外的IO线程，它是被动回调的。
- IO类型
  - BIO： 阻塞同步的IO。
  - 伪异步IO：  阻塞同步的IO。
  - NIO： 非阻塞同步的IO。
  - AIO： 非阻塞异步IO。
- API使用难度
  - BIO简单
  - 伪异步IO：简单
  - NIO、AIO复杂。
- 调试难度
  - BIO、伪异步IO：简单
  - NIO、AIO复杂。
- 可靠性
  - BIO简单：差
  - 伪异步IO：较差
  - NIO、AIO高。
- 吞吐量
  - BIO：低。
  - 伪异步IO：中等。
  - NIO、AIO比较高。



# 二、Netty入门

原生NIO的缺陷：

- 类库和API繁杂。
- 入门门槛高。
- 工作量和难度大。
- JDK NIO存在Bug。



Netty的优势：

分布式服务治理框架Dubbo使用了Netty作为底层通信框架，来童工高性能的异步通信能力。

- API简单，定制能力强。
- 入门门槛低。
- 性能高。
- 成熟、稳定。



# 三、WebSocket入门

WebSocket是H5提出的一个协议规范，WebSocket约定了一个通信的规范，通过一个握手机制，客户端和服务器之间就能够建立一个类似TCP的连接，从而方便客户端和服务器之间的通信。

在WebSocket出现之前，Web交互一般是基于HTTP协议的短连接或者长连接，那WebSocket是为同时解决客户端与服务端实时通信而产生的技术。

WebSocket协议本质上是一个基于TCP的协议，是先通过HTTP/HTTPS协议发起一条特殊的HTTP请求，进行握手后创建一个用于交换数据的TCP连接，此后服务端与客户端通过此TCP连接进行实时通信，要注意一点：当WebSocket的客户端与服务器端进行通信以后，此时就不再需要之前进行握手请求的HTTP协议的参与了。



【WebSocket优点】

- 节省通信开销。以前的WebServer实现推送技术或者即时通讯用的都是轮训，在特定的时间间隔（比如说1秒钟）由浏览器自动发起请求，将服务器的消息主动拉回来，在这种情况下需要不断地向服务器发请求，然而HTTPRequest的header是非常长的，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽和资源。
- 服务器主动传送数据给客户端。WebSocket最伟大的地方就是服务器和客户端可以在给定的时间范围内任意时刻相互推送信息。浏览器和服务器需要做一个握手的动作，在建立连接之后，服务器可以主动传送数据给客户端，客户端也可以随时向服务器发送数据，此外，服务器与客户端之间交换的标头信息也是非常小的。
- 实时通信。WebSocket并不仅限于ajax的方式进行通信。



【WebSocket建立连接】

- 客户端发起握手请求。
- 服务端响应请求。
- 连接建立。

过程描述：建立一个WebSocket连接，客户端或者浏览器首先向服务器发起一个HTTP请求，这个请求和普通的HTTP请求不同，包含了一些附加头信息，其中就有一个头信息叫做upgradeWebsocket。服务器端解析这些附加头信息，然后生成应答消息响应给客户端，客户端就与服务器端建立了相应的连接。



【WebSocket生命周期】

- 打开事件。发生在新的连接时调用。此事件发生在端点上建立连接时并且在任何其他事件发生之前。此事件伴随着三类信息：
  - WebSocket Session对象-用于表示已经建立好的连接；
  - 配置对象，包含了用来配置端点的信息。
  - 一组路径参数，用于打开阶段握手时WebSocket端入栈匹配的URI。
- 消息事件：接收WebSocket对话中另一端发送的消息。连接上消息将以三种基本形式抵达：
  - 文本消息
  - 二进制消息
  - 胖消息
    最基本的形式是选择选择使用在String参数方法来处理文本消息。ByteBuffer或者Byte数组方法处理二进制文本；消息如果仅仅是处理胖消息，可以Java WebSocket API中的胖Message接口的一个实例。
- 错误事件：WebSocket连接或者端点发生错误时产生。可以处理WebSocket实现入栈处理时发生的任何异常，处理入栈消息的时候可能会发生三种基本错误类型：
  - WebSocket建立连接的时候，可能发生错误，这些异常属于SessionException类型；
  - 当WebSocket实现试图将入栈消息解码成所需要的对象时，此类错误是DecodeException类型；
  - WebSocket端点的其他方法产生的运行错误，WebSocket实现将记录WebSocket端点操作过程中产生的任何异常 。
- 关闭事件：表示WebSocket端点的连接关闭。在WebSocket连接时做其他的通用清理工作，它可以由参与连接的任一端点发出。



【WebSocket关闭连接】

WebSocket提供了两种关闭方式：

1. 服务器关闭底层TCP连接；
2. 客户端发起TCP Close。

TCP连接正常情况下，应该是首先由服务器关闭，在异常情况下，客户端可以发起TCP Close。

因此，当服务器被指示关闭WebSocket连接时，应该发起一个TCP Close操作，客户端应该等待服务端的TCP Close。



# 四、Netty实现WebSocket

功能介绍：

- Netty开发服务端
- HTML实现客户端
- 实现服务端与客户端的实时交互



## 2.云计算加速向PaaS化与SaaS化演进

### 2.1 五大特征


### 2.2 PaaS技术不断创新



### 2.5 边缘云




